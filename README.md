# Verilog 2048game (FPGA VGA Basys3)

#### author: Zevick

## 基本描述

复旦2024秋季，数字逻辑基础（H）课程作业，本项目代码成功通过了Basys3的上板验证。

利用Verilog设计硬件电路，实现了简易的2048小游戏，并利用VGA端口输出640x480@60的显示画面。

## 功能概览

- [x] 使用开发板上button与switch做输入与重置按键
- [x] 计时器与7段数码管显示
- [x] VGA画面棋盘与动态**ascii**字符显示

## 成果展示

#### 游戏画面

![](https://github.com/theElysia/Verilog-2048game/blob/main/pics/%E8%BF%87%E7%A8%8B.PNG)

![](https://github.com/theElysia/Verilog-2048game/blob/main/pics/%E7%BB%93%E6%9D%9F.PNG)

#### 资源使用

![](https://github.com/theElysia/Verilog-2048game/blob/main/pics/%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8.png)

***

## 项目结构

game_top.v

> 1. game_kernel.v
>    1.  module: game_control（游戏控制内核及得分计算）
> 2. vga_modules.v
>    1. module: vga_control_sample（生成测试彩条）
>    2. module: vga_control（游戏画面显示控制模块）
>    3. module: ascii8x16（LUTRAM存储字符点阵）
> 3. segment_led_modules.v
>    1. module: display_7segment（七段数码管显示控制模块）
>    2. module: digit_to_7seg_patten（数字转七段数码管编码显示）
>    3. module: led_timer（秒表及七段数码管显示）
> 4. Zevick_lib.v
>    1. module: simple_counter（无加载功能的任意进制计数器）
>    2. module: frequency_divider（时钟偶数倍分频器）
>    3. module: async_to_sync（将异步多周期输入信号规整为给定时钟单周期信号）
>    4. module: binary_to_decimal（二进制数转十进制数，BCD编码）
>    5. module: random_8/32（LFSR型随机数生成器）



## 具体功能描述

#### 1.游戏描述

2048游戏，玩家可按照四个方向控制棋盘重力方向，在随重力下落时相邻相同棋子会合并，并得到合并后棋子面值的得分（比如，4与4合并，变成8，同时得到8分）。每次操作后，会在棋盘空余位置随机生成一个2，当某次操作后不再有空位时游戏结束。

本游戏为无尽模式，内置实现了最大可合成棋子8192。

画面左侧为棋盘，右侧显示当前得分以及游戏用时。当游戏结束时右下角会显示GAMEOVER字样，同时计时暂停，可通过重置按键重新游玩。

#### 2.操作

FPGA板上的上下左右四个按钮控制重力方向，中间的按钮为重置按键。下方开关为调试用，可分别独立控制VGA，计时器，游戏或整个系统的重置。

#### 3.技术重点

* 游戏内核简化
  * 考虑到四个方向的操作具有相似性，故考虑通过分级的方式重用电路，利用状态机实现。
  * stage1：等待输入
  * stage2：根据输入方向，将第i行（列）按移动方向存入一个缓存队列
  * stage3：利用栈，将缓存队列中的数合并，并计分，记录空位
  * stage4：将栈中数填回棋盘第i行（列），将计分合并至全局分数，累加空位数，i=i+1，若i<4则返回stage2，否则进入stage5
  * stage5：随机选定空位生成新的棋子进入stage1，或判定游戏结束进入stage6。发送出画面更新信号。
  * stage6：游戏结束，等待重置
  * 此6个阶段为功能上的大致划分，实际可能将某些阶段进一步细分。总体来说是重用电路，并尽量使得每一阶段的延时接近，以期获得更高工作频率。虽说在本项目中时序十分宽松，考虑到用户相邻输入都是在0.1s量级的。
* VGA时钟与同步信号
* VGA画面存储与时序约束
  * 由于FPGA资源限制，不太可能将整个画面存储下来
  * 类似有2级的寄存器，一级的寄存器为游戏的原始信号，二级的寄存器为画面辅助存储（如果资源够用这一级就可以换成整个画面的存储）。这样画面的生成只用依据画面辅助存储来快速产生，而不是需要再经过一个复杂的计算组合电路来实时计算各个点的像素值，可以满足时序要求，也可以使得画面更加稳定。
  * 画面的更新为事件驱动，根据游戏内核控制发出的更新信号来修改画面辅助存储寄存器内容。这样可以大大降低计算资源使用，降低功耗。
  * 本部分多处使用了线的concat，而不是使用/等算子，进一步优化时序，但比较难以阅读。
* 用户输入检测
* 重点函数：随机数生成（用于棋盘更新），二进制数转十进制数（用于得分显示）



## 技术难点分享

#### 1.随机数生成

线性反馈移位寄存器（Linear Feedback Shift Register，LFSR），利用反馈函数以及线性位移生成伪随机序列。

多项式f(x)的阶定义为使式子
$$
f(x)|(x^n-1)
$$
成立的最小n，而n级的m序列特征多项式的阶为2^n-1，可以利用这个来构造相应电路。（关于m序列可以直接查表得到）

有斐波那契LFSR与伽罗瓦LFSR两种类型，本项目采用伽罗瓦型（Galois），因为关键路径更短。且使用同或运算，故输出范围为
$$
[0 , 2^n-2]
$$

#### 2.二进制数转十进制数

使用名为**Double dabble**的技术，不断重复位移与加3操作。大致操作为从高位（有补0操作）开始扫描，每次4位，**若大于4，则加3**（详见代码）。

可以这样简单理解，每次移位相当于乘2，而+3在乘2后就变成+6，对于BCD编码相当于进位；大于4的数乘2后显然大于等于10，需要进位。通过每次判断位移与加3，用数学归纳法来理解，这样可以保证高位的BCD编码的正确性。

#### 3.VGA画面显示

为了减少保存画面的资源消耗，本部分在代码实现时仅存储了16\*4+32个ASCII字符点阵（16\*4为棋盘使用，32为右半画面显示使用）。为了进一步减轻时序压力（上述的存储模式相当于要实时计算并生成相当一部分画面内容），将640x480画布先按照64x64划分成基本块大小（选用2的幂次是避免取模运算），再对基本块填充色彩。

对于存储的字符点阵，我们也设置了事件驱动的更新策略。当其发生变化时，由game_kernel模块发出flush信号，接收到该信号时才会对画面进行更新。

